(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@tonaljs/tonal'), require('@tonaljs/midi')) :
  typeof define === 'function' && define.amd ? define(['exports', '@tonaljs/tonal', '@tonaljs/midi'], factory) :
  (global = global || self, factory(global.Note = {}, global.tonal, global.midi));
}(this, (function (exports, tonal, midi) { 'use strict';

  var toNoteName = function (sameAccidentals) { return function (noteName) {
      var n = tonal.note(noteName);
      if (n.empty) {
          return "";
      }
      var sharps = sameAccidentals ? n.alt > 0 : n.alt < 0;
      var pitchClass = n.midi === null;
      return midi.midiToNoteName(n.midi || n.chroma, { sharps: sharps, pitchClass: pitchClass });
  }; };
  /**
   * Simplify a note
   *
   * @function
   * @param {string} note - the note to be simplified
   * - sameAccType: default true. Use same kind of accidentals that source
   * @return {string} the simplfied note or '' if not valid note
   * @example
   * simplify("C##") // => "D"
   * simplify("C###") // => "D#"
   * simplify("C###")
   * simplify("B#4") // => "C5"
   */
  var simplify = toNoteName(true);
  /**
   * Get enharmonic of a note
   *
   * @function
   * @param {string} note
   * @return {string} the enhramonic note or '' if not valid note
   * @example
   * Note.enharmonic("Db") // => "C#"
   * Note.enhramonic("C") // => "C"
   */
  var enharmonic = toNoteName(false);
  /**
   * Transpose by an interval
   * @function
   * @param {string} interval
   * @return {function} a function that transposes by the given interval
   * @example
   * ["C", "D", "E"].map(transposeBy("5P"));
   * // => ["G", "A", "B"]
   */
  var transposeBy = function (interval) { return function (note) {
      return tonal.transpose(note, interval);
  }; };
  /**
   * Transpose from a note
   * @function
   * @param {string} note
   * @return {function}  a function that transposes the the note by an interval
   * ["1P", "3M", "5P"].map(transposeFrom("C"));
   * // => ["C", "E", "G"]
   */
  var transposeFrom = function (note) { return function (interval) {
      return tonal.transpose(note, interval);
  }; };
  /**
   * Transpose a note by a number of perfect fifths.
   *
   * @function
   * @param {string} note - the note name
   * @param {number} fifhts - the number of fifths
   * @return {string} the transposed note name
   *
   * @example
   * import { transposeFifths } from "@tonaljs/note"
   * transposeFifths("G4", 1) // => "D"
   * [0, 1, 2, 3, 4].map(fifths => transposeFifths("C", fifths)) // => ["C", "G", "D", "A", "E"]
   */
  function transposeFifths(noteName, fifths) {
      var n = tonal.note(noteName);
      if (n.empty) {
          return "";
      }
      var _a = n.coord, nFifths = _a[0], nOcts = _a[1];
      var transposed = nOcts === undefined
          ? tonal.coordToNote([nFifths + fifths])
          : tonal.coordToNote([nFifths + fifths, nOcts]);
      return transposed.name;
  }

  Object.defineProperty(exports, 'tokenize', {
    enumerable: true,
    get: function () {
      return tonal.tokenizeNote;
    }
  });
  exports.enharmonic = enharmonic;
  exports.simplify = simplify;
  exports.transposeBy = transposeBy;
  exports.transposeFifths = transposeFifths;
  exports.transposeFrom = transposeFrom;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=index.es5.js.map
